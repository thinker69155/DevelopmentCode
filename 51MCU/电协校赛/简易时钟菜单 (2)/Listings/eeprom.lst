C51 COMPILER V9.59.0.0   EEPROM                                                            11/13/2025 01:28:19 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE EEPROM
OBJECT MODULE PLACED IN .\Objects\eeprom.obj
COMPILER INVOKED BY: D:\software\keil\C51\BIN\C51.EXE eeprom.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\eeprom.lst) TABS(2) OBJECT(.\Objects\eeprom.obj)

line level    source

   1          #include "eeprom.h"
   2          #include <intrins.h>
   3          
   4          // -------------------------- 内部函数（仅本文件使用） --------------------------
   5          /**
   6           * @brief  关闭IAP/EEPROM操作（避免误触发）
   7           * @param  无
   8           * @retval 无
   9           */
  10          static void IAP_Disable(void) {
  11   1          IAP_CONTR = 0x00;  // 关闭IAP使能
*** ERROR C202 IN LINE 11 OF eeprom.c: 'IAP_CONTR': undefined identifier
  12   1          IAP_CMD   = 0x00;  // 清除命令寄存器
*** ERROR C202 IN LINE 12 OF eeprom.c: 'IAP_CMD': undefined identifier
  13   1          IAP_ADDRH = 0x00;  // 清除地址寄存器
*** ERROR C202 IN LINE 13 OF eeprom.c: 'IAP_ADDRH': undefined identifier
  14   1          IAP_ADDRL = 0x00;
*** ERROR C202 IN LINE 14 OF eeprom.c: 'IAP_ADDRL': undefined identifier
  15   1      }
  16          
  17          // -------------------------- 外部函数（供主文件调用） --------------------------
  18          void EEPROM_WriteByte(unsigned int addr, unsigned char dat) {
  19   1          EA = 0;  // 关闭总中断，避免操作过程中被打断
  20   1          IAP_CONTR = 0x81;  // 使能IAP（ISPEN=1，WAIT=0，12MHz晶振适配）
*** ERROR C202 IN LINE 20 OF eeprom.c: 'IAP_CONTR': undefined identifier
  21   1          IAP_CMD   = 0x02;  // 选择IAP写命令
*** ERROR C202 IN LINE 21 OF eeprom.c: 'IAP_CMD': undefined identifier
  22   1          IAP_ADDRH = addr >> 8;  // 地址高8位
*** ERROR C202 IN LINE 22 OF eeprom.c: 'IAP_ADDRH': undefined identifier
  23   1          IAP_ADDRL = addr & 0xFF; // 地址低8位
*** ERROR C202 IN LINE 23 OF eeprom.c: 'IAP_ADDRL': undefined identifier
  24   1          IAP_DATA  = dat;         // 写入的数据
*** ERROR C202 IN LINE 24 OF eeprom.c: 'IAP_DATA': undefined identifier
  25   1          _nop_(); _nop_();        // 延时，确保命令稳定
  26   1          IAP_TRIG  = 0x46;        // 触发IAP操作（必须按0x46→0xB9顺序）
*** ERROR C202 IN LINE 26 OF eeprom.c: 'IAP_TRIG': undefined identifier
  27   1          IAP_TRIG  = 0xB9;
*** ERROR C202 IN LINE 27 OF eeprom.c: 'IAP_TRIG': undefined identifier
  28   1          _nop_(); _nop_();
  29   1          IAP_Disable();  // 关闭IAP，防止误操作
  30   1          EA = 1;         // 开启总中断
  31   1      }
  32          
  33          unsigned char EEPROM_ReadByte(unsigned int addr) {
  34   1          unsigned char dat;
  35   1          EA = 0;  // 关闭总中断
  36   1          IAP_CONTR = 0x81;  // 使能IAP
*** ERROR C202 IN LINE 36 OF eeprom.c: 'IAP_CONTR': undefined identifier
  37   1          IAP_CMD   = 0x01;  // 选择IAP读命令
*** ERROR C202 IN LINE 37 OF eeprom.c: 'IAP_CMD': undefined identifier
  38   1          IAP_ADDRH = addr >> 8;
*** ERROR C202 IN LINE 38 OF eeprom.c: 'IAP_ADDRH': undefined identifier
  39   1          IAP_ADDRL = addr & 0xFF;
*** ERROR C202 IN LINE 39 OF eeprom.c: 'IAP_ADDRL': undefined identifier
C51 COMPILER V9.59.0.0   EEPROM                                                            11/13/2025 01:28:19 PAGE 2   

  40   1          _nop_(); _nop_();
  41   1          IAP_TRIG  = 0x46;  // 触发IAP操作
*** ERROR C202 IN LINE 41 OF eeprom.c: 'IAP_TRIG': undefined identifier
  42   1          IAP_TRIG  = 0xB9;
*** ERROR C202 IN LINE 42 OF eeprom.c: 'IAP_TRIG': undefined identifier
  43   1          _nop_(); _nop_();
  44   1          dat = IAP_DATA;    // 读取数据
*** ERROR C202 IN LINE 44 OF eeprom.c: 'IAP_DATA': undefined identifier
  45   1          IAP_Disable();     // 关闭IAP
  46   1          EA = 1;            // 开启总中断
  47   1          return dat;
  48   1      }
  49          
  50          void EEPROM_SaveCalendar(Calendar_TypeDef *cal) {
  51   1          // 日历数据按：年→月→日→时→分→秒 顺序存储（BCD码格式，适配RTC）
  52   1          EEPROM_WriteByte(EEPROM_ADDR_CAL + 0, (cal->year / 10) << 4 | (cal->year % 10));  // 年→BCD码
  53   1          EEPROM_WriteByte(EEPROM_ADDR_CAL + 1, (cal->month / 10) << 4 | (cal->month % 10));// 月→BCD码
  54   1          EEPROM_WriteByte(EEPROM_ADDR_CAL + 2, (cal->day / 10) << 4 | (cal->day % 10));    // 日→BCD码
  55   1          EEPROM_WriteByte(EEPROM_ADDR_CAL + 3, (cal->hour / 10) << 4 | (cal->hour % 10));  // 时→BCD码
  56   1          EEPROM_WriteByte(EEPROM_ADDR_CAL + 4, (cal->min / 10) << 4 | (cal->min % 10));    // 分→BCD码
  57   1          EEPROM_WriteByte(EEPROM_ADDR_CAL + 5, (cal->sec / 10) << 4 | (cal->sec % 10));    // 秒→BCD码
  58   1          
  59   1          EEPROM_WriteByte(EEPROM_ADDR_INIT_FLAG, 0xAA);  // 标记为已初始化
  60   1      }
  61          
  62          bit EEPROM_LoadCalendar(Calendar_TypeDef *cal) {
  63   1          unsigned char year_bcd, month_bcd, day_bcd;
  64   1          unsigned char hour_bcd, min_bcd, sec_bcd;
  65   1          
  66   1          // 先检查是否已初始化
  67   1          if (EEPROM_ReadByte(EEPROM_ADDR_INIT_FLAG) != 0xAA) {
  68   2              return 0;  // 未初始化，读取失败
  69   2          }
  70   1          
  71   1          // 读取BCD码格式的日历数据，转换为十进制
  72   1          year_bcd  = EEPROM_ReadByte(EEPROM_ADDR_CAL + 0);
  73   1          month_bcd = EEPROM_ReadByte(EEPROM_ADDR_CAL + 1);
  74   1          day_bcd   = EEPROM_ReadByte(EEPROM_ADDR_CAL + 2);
  75   1          hour_bcd  = EEPROM_ReadByte(EEPROM_ADDR_CAL + 3);
  76   1          min_bcd   = EEPROM_ReadByte(EEPROM_ADDR_CAL + 4);
  77   1          sec_bcd   = EEPROM_ReadByte(EEPROM_ADDR_CAL + 5);
  78   1          
  79   1          // BCD码→十进制（高4位=十位，低4位=个位）
  80   1          cal->year  = (year_bcd >> 4) * 10 + (year_bcd & 0x0F);
  81   1          cal->month = (month_bcd >> 4) * 10 + (month_bcd & 0x0F);
  82   1          cal->day   = (day_bcd >> 4) * 10 + (day_bcd & 0x0F);
  83   1          cal->hour  = (hour_bcd >> 4) * 10 + (hour_bcd & 0x0F);
  84   1          cal->min   = (min_bcd >> 4) * 10 + (min_bcd & 0x0F);
  85   1          cal->sec   = (sec_bcd >> 4) * 10 + (sec_bcd & 0x0F);
  86   1          
  87   1          return 1;  // 读取成功
  88   1      }
  89          
  90          bit EEPROM_CheckInit(void) {
  91   1          return (EEPROM_ReadByte(EEPROM_ADDR_INIT_FLAG) == 0xAA) ? 1 : 0;
  92   1      }

C51 COMPILATION COMPLETE.  0 WARNING(S),  18 ERROR(S)
